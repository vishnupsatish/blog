---
title: Solving “Disjoint Set Test” on DMOJ
date: 2021-06-11 8:00:00 -0400
category: [programming, competitive programming]
tag: [graph theory]
published: false
---

<!-- <a href="#"><img src="https://antique-fringe-fennel.glitch.me/badge?page_id=2021-06-06-ac19p5.md"></a>-->


## Problem
Problem link: [https://dmoj.ca/problem/ds2](https://dmoj.ca/problem/ds2){:target="_blank"}

Problem type: Graph theory

This problem asks us to implement a program that outputs the number of edges in the minimum spanning tree of a weighted, undirected graph. Though we are not given the weights of each edge, we are given that "an edge that shows up earlier in the input has a strictly less weight than an edge that shows up later in the input". If there is no minimum spanning tree (i.e. the graph is not connected) we output "Disconnected Graph".

## Solution

What is a minimum spanning tree? A minimun spanning tree, in a connected, undirected, weighted graph, is the series of edges that connect the enitre graph, while using minimum total edge weight (sum of all weights of the edges visited by the MST).

Below is an example of a minimum spanning tree of a graph.

![Minimum spanning tree](https://res.cloudinary.com/dnwczwamg/image/upload/b_rgb:ffffff/v1623076536/vishnu-blog/posts/2021-06-07-ds2/mst.png){:width="50%"}

What is a disjoint-set data structure? It is a data structure that is used to store a collection of elements which are part of non-overlapping sets, with each set having a representative element. 

A disjoint-set (with path compression optimization) has two main operations. The data structure can also be stored in an array, where the value with index `i` in the array represents `i`'s parent element's index.

- Find
    - Returns the representative of a node's set, and sets all nodes in between (including the node passed to the function) to be direct children of the representative
- Merge
    - Merges two sets (adds an edge between the representative of the sets of the nodes given)


```
int find(node v) {
    if ds[v] != v:
        ds[v] = find(ds[v])
    return ds[v]
}

void merge(node v, node u) {
    ds[find(v)] = find(u)
}
```

Below is an example of how the disjoint-set data structure works.

Assume we have 10 elements to begin with, and all elements are part of their own set. Each set's representative is the sole element in that set.

![](https://res.cloudinary.com/dnwczwamg/image/upload/vishnu-blog/posts/2021-06-07-ds2/disjoint-set-step1.png){:width="50%"}

Let's merge 1 and 2. An edge is added between 1 and 2.
`merge(1, 2)`

![](https://res.cloudinary.com/dnwczwamg/image/upload/vishnu-blog/posts/2021-06-07-ds2/disjoint-set-step2.png){:width="50%"}

Let's now merge 4 and 1. An edge is added between 4 and 1's representative, which is 2.

![](https://res.cloudinary.com/dnwczwamg/image/upload/vishnu-blog/posts/2021-06-07-ds2/disjoint-set-step3.png){:width="50%"}

Now, let's merge 2 and 3. An edge is added between each node's representative.

![](https://res.cloudinary.com/dnwczwamg/image/upload/vishnu-blog/posts/2021-06-07-ds2/disjoint-set-step4.png){:width="50%"}

If we were to call `find(1)` now (finding 1's representative), it would return 3, and it would also make 1's direct parent 3. This is known as the path compression optimization.

![](https://res.cloudinary.com/dnwczwamg/image/upload/vishnu-blog/posts/2021-06-07-ds2/disjoint-set-step5.png){:width="50%"}

You might be wondering how the disjoint-set data structure relates to finding the minimum spanning tree of a graph. Finding the minimum spanning tree of a graph can be achieved by using either Prim's or Kruskal's algorithm. We'll be using Kruskal's algorithm for this problem.

The idea of Kruskal's algorithm is to sort each edge in non-decreasing order by its weight (which is conveniently how the edges are given in the input), then add an edge between 


